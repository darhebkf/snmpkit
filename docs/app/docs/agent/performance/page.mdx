# Performance

Performance comparison between snmpkit (Rust core) and pyagentx3 (pure Python).

## Benchmarks

import { AgentBenchmarks } from "@/components/BenchmarkChart"

<AgentBenchmarks />

## Analysis

### PDU Encode: 11.5x faster

The most critical operation for agent response times. snmpkit encodes PDUs in Rust with zero-copy byte handling, while pyagentx3 uses Python's `struct.pack` with multiple allocations.

### Value Create: 6.4x faster

Creating SNMP values (Integer, OctetString, Counter64, etc.) is significantly faster in Rust. This benefits agents with large table responses where thousands of values are created per request.

### OID Parse: 1.5x faster

Parsing OID strings like "1.3.6.1.4.1.12345" into internal representation. snmpkit uses a Rust parser with pre-allocated buffers.

### Header Decode: ~1x (equal)

Header decode is roughly equal between implementations. This 20-byte operation is so fast (~1M ops/sec) that the PyO3 FFI overhead of crossing the Python↔Rust boundary negates the Rust speedup. This is expected and acceptable since:

1. Header decode happens once per PDU (not a bottleneck)
2. The operations that matter (encode, value creation) are much faster
3. Real-world performance is dominated by network I/O

## Test Environment

| Component | Specification |
|-----------|---------------|
| CPU | AMD Ryzen 7 5800X (8C/16T, 3.8GHz base) |
| Memory | 64GB DDR4 3600MHz CL18 |
| OS | Ubuntu 22.04 LTS (WSL2) |
| Python | 3.14 (free-threaded) |
| Rust | 1.83.0 |

All benchmarks measure raw encoding/decoding performance without network I/O overhead. Each operation runs 10,000 iterations.

## Real-World Impact

### Response Latency

For a typical SNMP GET request with 10 OIDs:

| Operation | pyagentx3 | snmpkit |
|-----------|-----------|---------|
| Decode header | 1 μs | 1 μs |
| Create 10 values | 192 μs | 30 μs |
| Encode response | 588 μs | 51 μs |
| **Total** | **781 μs** | **82 μs** |

snmpkit responds ~9.5x faster before network latency.

### Throughput

At 1000 OIDs per response:

- pyagentx3: ~500 responses/sec (bottlenecked by encoding)
- snmpkit: ~5,000 responses/sec (bottlenecked by network)

### Memory

snmpkit uses less memory per OID:

- pyagentx3: OIDs stored as Python strings with full object overhead
- snmpkit: OIDs stored as compact Rust tuples, exposed to Python on-demand

## Optimization Tips

### Enable Parallel Encoding

For agents serving 1000+ OIDs:

```python
agent = Agent(parallel_encoding=True)
```

This uses Rust's rayon for multi-threaded PDU encoding.

### Tune Update Frequency

Don't update faster than needed:

```python
# Fast updates only where necessary
agent.register("1.3.6.1.4.1.12345.1", RealtimeMetrics(), freq=1)

# Slow updates for stable data
agent.register("1.3.6.1.4.1.12345.2", ConfigData(), freq=60)
```

### Use Appropriate Types

Counter64 is larger to encode than Integer32. Use the smallest type that fits your data:

```python
# Good: use Counter32 for values < 4 billion
self.set_COUNTER32("1.0", packet_count)

# Only use Counter64 when needed
self.set_COUNTER64("2.0", bytes_transferred)
```

## Reproducing Benchmarks

Run the benchmarks yourself:

```bash
cd benchmarks
python run_benchmarks.py
```

Results are saved to `benchmarks/results.json`.
